#include <iostream>
#include <vector>
#include <list>
#include <forward_list>
#include <algorithm>

// 53page 표의 내용입니다.

// 1. 입력 반복자 : =*p(입력), ++
// 2. 출력 반복자 : *p=(출력), ++

// 위 2개는 멀티 패스를 보장하지 않고
// ===========================================
// 아래3개는 멀티 패스를 보장합니다

// 3. 전진형 반복자 : 입력, ++				싱글리스트의 반복자
// 4. 양방향 반복자 : 입력, ++, --			더블리스트의 반복자

// 5. 임의접근 반복자 : 입력, ++, --, +, -, [],	연속된 메모리와 유사한 구조
//											vector 의 반복자
// 
// continuous iterator ( C++17 에서 추가) 아직은 널리 사용되지 않음.







int main()
{
	std::forward_list<int> s1 = { 1,2,3 };
	std::list<int> s2 = { 1,2,3 };
	std::vector<int> v = { 1,2,3,4,5,6,7,8,9,10 };


	// find 알고리즘은 주어진 구간에서 선형검색을 합니다.
	// 1, 2번째 인자는 모두 반복자 입니다.

	// => 1, 2번째 인자가 가지는 최소 요구 조건을 위 5가지 카테고리에서
	//    선택해 보세요
	// => 최소 요구 조건은 입력 반복자 입니다.
	auto p = std::find(v.begin(), v.end(), 5);

	std::reverse(v.begin(), v.end());
		// 1, 2번째 인자의 최소 요구 조건은 ?
		// -- 연산이 가능한 반복자만 됩니다.
		// 양방향 반복자만 됩니다.

	// 현재 s1은 싱글리스트, s2는 더블리스트 입니다.
	std::reverse(s1.begin(), s1.end()); // error
	std::reverse(s2.begin(), s2.end()); // ok

	// std::sort 는 퀵 소트 알고리즘을 사용합니다.
	// 인자로 전달하는 반복자의 최소 요구 조건은  ?
	// => 반복자가 - 연산이 가능해야 합니다.
	// => 임의 접근 반복자만 가능합니다.
	std::sort(v.begin(), v.end());  // ok.. vector 반복자 임의접근

//	std::sort(s2.begin(), s2.end()); // 더블리스트 반복자 error

	// 더블리스트는 퀵소트은 안되지만(그래서 std::sort 에 보낼수 없지만)
	// 다른 sort 알고리즘으로는 sort 할수 있습니다.

	// 그래서 std::list 는 별도의 sort 멤버 함수가 있습니다.
	s2.sort(); // 퀵이 아닌 다른 알고리즘

	// 질문!!
	std::vector<int> v2 = { 1,2,3 };

	v2.sort();	// vector 는 이 멤버 함수가 있을까요 ?
				// 없을까요 ?
				// vector 는 임의 접근 반복자 를 가지므로 
				// 모든 알고리즘 사용가능 
				// std::sort() 에 전달 가능하므로
				// 멤버 함수 sort 를 별도로 제공할 필요 없습니다.

}

// 설명하는 용도이지, 체크 하지는 않나요 ?? => 네 정확합니다.!!

// T가 특정조건을 만족하는지 판단하는 경우가 있나요 ??
// => C++17 까지는 없습니다.
// 
// => C++20 부터는 만족하는지 판단하는 문법이 생겼습니다 Concept 이라는 문법
//    그래서 C++20 의 모든 알고리즘(find, reverse, sort등)은 
//    조건을 만족하는지 조사하는 코드 추가되어 있습니다.
//    그래서, std::sort(리스트 반복자) 하면 에러가 아주 보기 좋게 나옵니다.
//    => "임의 접근 반복자가 아닙니다" 라는 에러.